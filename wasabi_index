/***
 * Wasabi S3 Index - Cloudflare Workers (DOWNLOAD FIXED)
 * Fixed file path encoding for downloads and previews
 ***/

// Configuration
const CONFIG = {
  siteName: "Wasabi S3 Index",
  siteIcon: "🪣",
  theme: "dark",
  defaultPath: "",
  passwordProtected: false,
  password: "",
};

// Wasabi region endpoints
const WASABI_ENDPOINTS = {
  "us-east-1": "s3.wasabisys.com",
  "us-east-2": "s3.us-east-2.wasabisys.com",
  "us-west-1": "s3.us-west-1.wasabisys.com",
  "eu-central-1": "s3.eu-central-1.wasabisys.com",
  "eu-central-2": "s3.eu-central-2.wasabisys.com",
  "eu-west-1": "s3.eu-west-1.wasabisys.com",
  "eu-west-2": "s3.eu-west-2.wasabisys.com",
  "ap-northeast-1": "s3.ap-northeast-1.wasabisys.com",
  "ap-northeast-2": "s3.ap-northeast-2.wasabisys.com",
  "ap-southeast-1": "s3.ap-southeast-1.wasabisys.com",
  "ap-southeast-2": "s3.ap-southeast-2.wasabisys.com",
};

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = decodeURIComponent(url.pathname).replace(/^\//, "");

    if (CONFIG.passwordProtected && !await checkAuth(request, CONFIG.password)) {
      return new Response(getPasswordPage(), {
        status: 401,
        headers: {
          "Content-Type": "text/html",
          "WWW-Authenticate": 'Basic realm="Wasabi S3 Index"',
        },
      });
    }

    try {
      if (url.searchParams.get("download") !== null) {
        return await handleDownload(env, path);
      } else if (url.searchParams.get("preview") !== null) {
        return await handlePreview(env, path);
      } else {
        return await handleBrowse(env, path);
      }
    } catch (error) {
      console.error("Error:", error);
      return new Response(getErrorPage(error.message || "An error occurred"), {
        status: error.status || 500,
        headers: { "Content-Type": "text/html" },
      });
    }
  },
};

async function checkAuth(request, password) {
  const authHeader = request.headers.get("Authorization");
  if (!authHeader) return false;
  const [scheme, encoded] = authHeader.split(" ");
  if (scheme !== "Basic") return false;
  const decoded = atob(encoded);
  const [username, pwd] = decoded.split(":");
  return pwd === password;
}

// AWS URI encoding for canonical request
function awsUriEncode(str, encodeSlash = true) {
  let encoded = encodeURIComponent(str)
    .replace(/[!'()*]/g, c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
  
  if (!encodeSlash) {
    encoded = encoded.replace(/%2F/g, '/');
  }
  
  return encoded;
}

// Create canonical query string
function createCanonicalQueryString(params) {
  const sortedKeys = Object.keys(params).sort();
  return sortedKeys
    .map(key => `${awsUriEncode(key)}=${awsUriEncode(params[key])}`)
    .join('&');
}

// AWS Signature V4
async function signRequest(env, method, path, queryParams = {}, payload = "") {
  const region = env.WASABI_REGION || "us-east-1";
  const baseEndpoint = WASABI_ENDPOINTS[region] || WASABI_ENDPOINTS["us-east-1"];
  const bucket = env.WASABI_BUCKET_NAME;
  const service = "s3";
  
  const endpoint = `${bucket}.${baseEndpoint}`;
  
  const now = new Date();
  const dateStamp = now.toISOString().replace(/[:\-]|\.\d{3}/g, "").slice(0, 8);
  const amzDate = now.toISOString().replace(/[:\-]|\.\d{3}/g, "");
  
  const payloadHash = await sha256(payload);
  
  // Encode path for canonical URI - encode each segment but keep slashes
  const pathSegments = path.split('/').map(segment => awsUriEncode(segment, true));
  const canonicalUri = path ? '/' + pathSegments.join('/') : '/';
  
  const canonicalQueryString = createCanonicalQueryString(queryParams);
  
  const canonicalHeaders = `host:${endpoint}\nx-amz-content-sha256:${payloadHash}\nx-amz-date:${amzDate}\n`;
  const signedHeaders = "host;x-amz-content-sha256;x-amz-date";
  
  const canonicalRequest = `${method}\n${canonicalUri}\n${canonicalQueryString}\n${canonicalHeaders}\n${signedHeaders}\n${payloadHash}`;
  
  const algorithm = "AWS4-HMAC-SHA256";
  const credentialScope = `${dateStamp}/${region}/${service}/aws4_request`;
  const stringToSign = `${algorithm}\n${amzDate}\n${credentialScope}\n${await sha256(canonicalRequest)}`;
  
  const signingKey = await getSignatureKey(env.WASABI_SECRET_ACCESS_KEY, dateStamp, region, service);
  const signature = await hmacSha256(signingKey, stringToSign);
  
  const authorizationHeader = `${algorithm} Credential=${env.WASABI_ACCESS_KEY_ID}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
  
  // Build actual URL - use same encoding as canonical URI
  const urlParams = new URLSearchParams(queryParams);
  const urlString = `https://${endpoint}${canonicalUri}${urlParams.toString() ? '?' + urlParams.toString() : ''}`;
  
  return {
    url: urlString,
    headers: {
      "Host": endpoint,
      "x-amz-date": amzDate,
      "x-amz-content-sha256": payloadHash,
      "Authorization": authorizationHeader,
    },
  };
}

async function sha256(message) {
  const msgBuffer = new TextEncoder().encode(message);
  const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
}

async function hmacSha256(key, message) {
  const encoder = new TextEncoder();
  const keyData = typeof key === "string" ? encoder.encode(key) : key;
  const cryptoKey = await crypto.subtle.importKey(
    "raw", keyData, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(message));
  const hashArray = Array.from(new Uint8Array(signature));
  return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
}

async function getSignatureKey(key, dateStamp, regionName, serviceName) {
  const encoder = new TextEncoder();
  const kDate = await hmacSha256Raw(encoder.encode("AWS4" + key), dateStamp);
  const kRegion = await hmacSha256Raw(kDate, regionName);
  const kService = await hmacSha256Raw(kRegion, serviceName);
  const kSigning = await hmacSha256Raw(kService, "aws4_request");
  return kSigning;
}

async function hmacSha256Raw(key, message) {
  const encoder = new TextEncoder();
  const keyData = typeof key === "string" ? encoder.encode(key) : key;
  const cryptoKey = await crypto.subtle.importKey(
    "raw", keyData, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(message));
  return new Uint8Array(signature);
}

async function listObjects(env, prefix = "", delimiter = "/") {
  const queryParams = {
    "list-type": "2",
    "delimiter": delimiter,
    "max-keys": "1000",
  };
  
  if (prefix) {
    queryParams.prefix = prefix;
  }
  
  const { url, headers } = await signRequest(env, "GET", "", queryParams);
  
  const response = await fetch(url, { headers });
  
  if (!response.ok) {
    const text = await response.text();
    throw { message: `Failed to list objects: ${text}`, status: response.status };
  }
  
  const xmlText = await response.text();
  return parseListBucketResult(xmlText);
}

function parseListBucketResult(xml) {
  const folders = [];
  const files = [];
  
  const prefixMatches = xml.matchAll(/<CommonPrefixes>.*?<Prefix>(.*?)<\/Prefix>.*?<\/CommonPrefixes>/gs);
  for (const match of prefixMatches) {
    const prefix = match[1];
    const name = prefix.replace(/\/$/, "").split("/").pop();
    folders.push({ name, prefix });
  }
  
  const contentMatches = xml.matchAll(/<Contents>(.*?)<\/Contents>/gs);
  for (const match of contentMatches) {
    const content = match[1];
    const keyMatch = content.match(/<Key>(.*?)<\/Key>/);
    const sizeMatch = content.match(/<Size>(.*?)<\/Size>/);
    const modifiedMatch = content.match(/<LastModified>(.*?)<\/LastModified>/);
    
    if (keyMatch) {
      const key = keyMatch[1];
      if (key.endsWith("/")) continue;
      
      const name = key.split("/").pop();
      const size = sizeMatch ? parseInt(sizeMatch[1]) : 0;
      const lastModified = modifiedMatch ? modifiedMatch[1] : "";
      
      files.push({ name, key, size, lastModified });
    }
  }
  
  return { folders, files };
}

async function handleDownload(env, path) {
  if (!path) {
    throw { message: "No file path provided", status: 400 };
  }
  
  const { url, headers } = await signRequest(env, "GET", path, {});
  
  const response = await fetch(url, { headers });
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error("Download error:", errorText);
    throw { message: `Failed to download file: ${response.status} ${response.statusText}`, status: response.status };
  }
  
  const fileName = path.split("/").pop();
  const fileType = fileName.split(".").pop().toLowerCase();
  const contentType = getContentType(fileType);
  
  return new Response(response.body, {
    headers: {
      "Content-Type": contentType,
      "Content-Disposition": `attachment; filename="${fileName}"`,
      "Cache-Control": "public, max-age=3600",
      "Accept-Ranges": "bytes",
    },
  });
}

async function handlePreview(env, path) {
  if (!path) {
    throw { message: "No file path provided", status: 400 };
  }
  
  const { url, headers } = await signRequest(env, "GET", path, {});
  
  const response = await fetch(url, { headers });
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error("Preview error:", errorText);
    throw { message: `Failed to preview file: ${response.status} ${response.statusText}`, status: response.status };
  }
  
  const fileName = path.split("/").pop();
  const fileType = fileName.split(".").pop().toLowerCase();
  const contentType = getContentType(fileType);
  
  return new Response(response.body, {
    headers: {
      "Content-Type": contentType,
      "Content-Disposition": `inline; filename="${fileName}"`,
      "Cache-Control": "public, max-age=3600",
    },
  });
}

async function handleBrowse(env, path) {
  const prefix = path ? (path.endsWith("/") ? path : path + "/") : "";
  const { folders, files } = await listObjects(env, prefix);
  
  const html = getBrowsePage(path, folders, files);
  
  return new Response(html, {
    headers: { 
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "public, max-age=300",
    },
  });
}

function getContentType(ext) {
  const types = {
    html: "text/html", htm: "text/html", txt: "text/plain", css: "text/css",
    js: "text/javascript", json: "application/json", xml: "text/xml",
    jpg: "image/jpeg", jpeg: "image/jpeg", png: "image/png", gif: "image/gif",
    svg: "image/svg+xml", ico: "image/x-icon", webp: "image/webp",
    mp4: "video/mp4", webm: "video/webm", mkv: "video/x-matroska",
    avi: "video/x-msvideo", mov: "video/quicktime", mp3: "audio/mpeg",
    wav: "audio/wav", ogg: "audio/ogg", m4a: "audio/mp4", flac: "audio/flac",
    pdf: "application/pdf", doc: "application/msword",
    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    xls: "application/vnd.ms-excel",
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ppt: "application/vnd.ms-powerpoint",
    pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    zip: "application/zip", rar: "application/x-rar-compressed",
    "7z": "application/x-7z-compressed", tar: "application/x-tar", gz: "application/gzip",
  };
  return types[ext] || "application/octet-stream";
}

function formatSize(bytes) {
  if (bytes === 0) return "0 B";
  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

function formatDate(dateString) {
  const date = new Date(dateString);
  return date.toLocaleString();
}

function getFileIcon(name) {
  const ext = name.split(".").pop().toLowerCase();
  const icons = {
    pdf: "📄", doc: "📝", docx: "📝", txt: "📝", xls: "📊", xlsx: "📊", csv: "📊",
    ppt: "📽️", pptx: "📽️", jpg: "🖼️", jpeg: "🖼️", png: "🖼️", gif: "🖼️",
    svg: "🖼️", webp: "🖼️", mp4: "🎬", avi: "🎬", mkv: "🎬", mov: "🎬", webm: "🎬",
    mp3: "🎵", wav: "🎵", ogg: "🎵", flac: "🎵", m4a: "🎵",
    zip: "📦", rar: "📦", "7z": "📦", tar: "📦", gz: "📦",
    js: "💻", py: "💻", java: "💻", cpp: "💻", html: "💻", css: "💻",
  };
  return icons[ext] || "📄";
}

function getBrowsePage(currentPath, folders, files) {
  const pathParts = currentPath ? currentPath.split("/").filter(p => p) : [];
  const breadcrumbs = pathParts.map((part, index) => {
    const path = "/" + pathParts.slice(0, index + 1).join("/");
    return `<a href="${path}">${part}</a>`;
  }).join(" / ");

  const folderRows = folders.map(folder => `
    <tr class="folder-row">
      <td class="icon">📁</td>
      <td class="name"><a href="/${folder.prefix}">${folder.name}</a></td>
      <td class="size">-</td>
      <td class="modified">-</td>
      <td class="actions"><a href="/${folder.prefix}" class="btn">Open</a></td>
    </tr>
  `).join("");

  const fileRows = files.map(file => `
    <tr class="file-row">
      <td class="icon">${getFileIcon(file.name)}</td>
      <td class="name">${file.name}</td>
      <td class="size">${formatSize(file.size)}</td>
      <td class="modified">${formatDate(file.lastModified)}</td>
      <td class="actions">
        <a href="/${file.key}?download" class="btn btn-download">Download</a>
        ${isPreviewable(file.name) ? `<a href="/${file.key}?preview" class="btn btn-preview">Preview</a>` : ""}
      </td>
    </tr>
  `).join("");

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${CONFIG.siteName}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: ${CONFIG.theme === "dark" ? "#1a1a1a" : "#f5f5f5"};
      color: ${CONFIG.theme === "dark" ? "#e0e0e0" : "#333"};
      padding: 20px; line-height: 1.6;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    header {
      display: flex; align-items: center; margin-bottom: 30px; padding-bottom: 20px;
      border-bottom: 2px solid ${CONFIG.theme === "dark" ? "#333" : "#ddd"};
    }
    .site-icon { font-size: 48px; margin-right: 20px; }
    h1 { font-size: 32px; font-weight: 600; }
    .breadcrumb {
      background: ${CONFIG.theme === "dark" ? "#252525" : "#fff"};
      padding: 15px 20px; border-radius: 8px; margin-bottom: 20px; font-size: 14px;
    }
    .breadcrumb a { color: #0066cc; text-decoration: none; transition: color 0.2s; }
    .breadcrumb a:hover { color: #0052a3; text-decoration: underline; }
    table {
      width: 100%; background: ${CONFIG.theme === "dark" ? "#252525" : "#fff"};
      border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    th {
      background: ${CONFIG.theme === "dark" ? "#1e1e1e" : "#f8f8f8"};
      padding: 15px; text-align: left; font-weight: 600;
      border-bottom: 2px solid ${CONFIG.theme === "dark" ? "#333" : "#e0e0e0"};
    }
    td { padding: 12px 15px; border-bottom: 1px solid ${CONFIG.theme === "dark" ? "#333" : "#f0f0f0"}; }
    tr:last-child td { border-bottom: none; }
    tr:hover { background: ${CONFIG.theme === "dark" ? "#2a2a2a" : "#f9f9f9"}; }
    .icon { width: 40px; text-align: center; font-size: 20px; }
    .name { font-weight: 500; }
    .name a { color: ${CONFIG.theme === "dark" ? "#4d9fff" : "#0066cc"}; text-decoration: none; }
    .name a:hover { text-decoration: underline; }
    .size { width: 100px; }
    .modified { width: 200px; font-size: 13px; color: ${CONFIG.theme === "dark" ? "#888" : "#666"}; }
    .actions { width: 220px; white-space: nowrap; }
    .btn {
      display: inline-block; padding: 6px 12px; margin-right: 5px;
      background: #0066cc; color: white; text-decoration: none;
      border-radius: 4px; font-size: 12px; transition: background 0.2s;
    }
    .btn:hover { background: #0052a3; }
    .btn-preview { background: #28a745; }
    .btn-preview:hover { background: #218838; }
    .empty {
      text-align: center; padding: 60px 20px;
      color: ${CONFIG.theme === "dark" ? "#666" : "#999"};
    }
    footer {
      text-align: center; margin-top: 40px; padding-top: 20px;
      border-top: 1px solid ${CONFIG.theme === "dark" ? "#333" : "#ddd"};
      color: ${CONFIG.theme === "dark" ? "#666" : "#999"}; font-size: 14px;
    }
    @media (max-width: 768px) {
      .modified { display: none; }
      .actions { width: 150px; }
      .btn { padding: 5px 8px; font-size: 11px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="site-icon">${CONFIG.siteIcon}</div>
      <div><h1>${CONFIG.siteName}</h1></div>
    </header>
    <div class="breadcrumb">
      <a href="/">🏠 Home</a>
      ${breadcrumbs ? " / " + breadcrumbs : ""}
    </div>
    ${folders.length === 0 && files.length === 0 ? `
      <div class="empty"><h2>📭 Empty Folder</h2><p>No files or folders here</p></div>
    ` : `
      <table>
        <thead>
          <tr>
            <th class="icon"></th>
            <th class="name">Name</th>
            <th class="size">Size</th>
            <th class="modified">Modified</th>
            <th class="actions">Actions</th>
          </tr>
        </thead>
        <tbody>${folderRows}${fileRows}</tbody>
      </table>
    `}
    <footer><p>🪣 Powered by Wasabi S3 Index on Cloudflare Workers</p></footer>
  </div>
</body>
</html>`;
}

function isPreviewable(name) {
  const ext = name.split(".").pop().toLowerCase();
  const previewable = ["jpg", "jpeg", "png", "gif", "svg", "webp", "pdf", "txt", "mp4", "webm", "mp3", "wav", "ogg"];
  return previewable.includes(ext);
}

function getPasswordPage() {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Protected - ${CONFIG.siteName}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #1a1a1a; color: #e0e0e0; display: flex;
      justify-content: center; align-items: center; height: 100vh; margin: 0;
    }
    .container {
      text-align: center; background: #252525; padding: 40px;
      border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    h1 { margin-bottom: 20px; }
    p { margin-bottom: 30px; color: #999; }
  </style>
</head>
<body>
  <div class="container">
    <h1>🔒 Protected Area</h1>
    <p>Please enter the password to access this content</p>
  </div>
</body>
</html>`;
}

function getErrorPage(message) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Error - ${CONFIG.siteName}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #1a1a1a; color: #e0e0e0; display: flex;
      justify-content: center; align-items: center; height: 100vh; margin: 0;
    }
    .container {
      text-align: center; background: #252525; padding: 40px;
      border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-width: 500px;
    }
    h1 { color: #ff6b6b; margin-bottom: 20px; }
    p { margin-bottom: 30px; word-break: break-word; }
    a { 
      color: #4d9fff; text-decoration: none; padding: 10px 20px;
      background: #333; border-radius: 6px; display: inline-block;
      transition: background 0.2s;
    }
    a:hover { background: #444; }
  </style>
</head>
<body>
  <div class="container">
    <h1>⚠️ Error</h1>
    <p>${message}</p>
    <a href="/">← Back to Home</a>
  </div>
</body>
</html>`;
}
