/***
 * Wasabi S3 Index - Cloudflare Workers (ENHANCED MKV SUPPORT)
 * Uses MIME type tricks and browser detection for better MKV compatibility
 ***/

// Configuration
const CONFIG = {
  siteName: "Wasabi S3 Index",
  siteIcon: "ü™£",
  theme: "dark",
  defaultPath: "",
  passwordProtected: false,
  password: "",
  // Try to play MKV as WebM for better compatibility
  experimentalMkvSupport: true,
};

// Wasabi region endpoints
const WASABI_ENDPOINTS = {
  "us-east-1": "s3.wasabisys.com",
  "us-east-2": "s3.us-east-2.wasabisys.com",
  "us-west-1": "s3.us-west-1.wasabisys.com",
  "eu-central-1": "s3.eu-central-1.wasabisys.com",
  "eu-central-2": "s3.eu-central-2.wasabisys.com",
  "eu-west-1": "s3.eu-west-1.wasabisys.com",
  "eu-west-2": "s3.eu-west-2.wasabisys.com",
  "ap-northeast-1": "s3.ap-northeast-1.wasabisys.com",
  "ap-northeast-2": "s3.ap-northeast-2.wasabisys.com",
  "ap-southeast-1": "s3.ap-southeast-1.wasabisys.com",
  "ap-southeast-2": "s3.ap-southeast-2.wasabisys.com",
};

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = decodeURIComponent(url.pathname).replace(/^\//, "");

    if (CONFIG.passwordProtected && !await checkAuth(request, CONFIG.password)) {
      return new Response(getPasswordPage(), {
        status: 401,
        headers: {
          "Content-Type": "text/html",
          "WWW-Authenticate": 'Basic realm="Wasabi S3 Index"',
        },
      });
    }

    try {
      if (url.searchParams.get("download") !== null) {
        return await handleDownload(env, path);
      } else if (url.searchParams.get("preview") !== null) {
        return await handlePreview(env, path, request);
      } else if (url.searchParams.get("stream") !== null) {
        // Direct streaming endpoint for video player
        return await handleStream(env, path);
      } else {
        return await handleBrowse(env, path);
      }
    } catch (error) {
      console.error("Error:", error);
      return new Response(getErrorPage(error.message || "An error occurred"), {
        status: error.status || 500,
        headers: { "Content-Type": "text/html" },
      });
    }
  },
};

async function checkAuth(request, password) {
  const authHeader = request.headers.get("Authorization");
  if (!authHeader) return false;
  const [scheme, encoded] = authHeader.split(" ");
  if (scheme !== "Basic") return false;
  const decoded = atob(encoded);
  const [username, pwd] = decoded.split(":");
  return pwd === password;
}

// AWS URI encoding for canonical request
function awsUriEncode(str, encodeSlash = true) {
  let encoded = encodeURIComponent(str)
    .replace(/[!'()*]/g, c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
  
  if (!encodeSlash) {
    encoded = encoded.replace(/%2F/g, '/');
  }
  
  return encoded;
}

// Create canonical query string
function createCanonicalQueryString(params) {
  const sortedKeys = Object.keys(params).sort();
  return sortedKeys
    .map(key => `${awsUriEncode(key)}=${awsUriEncode(params[key])}`)
    .join('&');
}

// AWS Signature V4
async function signRequest(env, method, path, queryParams = {}, payload = "") {
  const region = env.WASABI_REGION || "us-east-1";
  const baseEndpoint = WASABI_ENDPOINTS[region] || WASABI_ENDPOINTS["us-east-1"];
  const bucket = env.WASABI_BUCKET_NAME;
  const service = "s3";
  
  const endpoint = `${bucket}.${baseEndpoint}`;
  
  const now = new Date();
  const dateStamp = now.toISOString().replace(/[:\-]|\.\d{3}/g, "").slice(0, 8);
  const amzDate = now.toISOString().replace(/[:\-]|\.\d{3}/g, "");
  
  const payloadHash = await sha256(payload);
  
  // Encode path for canonical URI - encode each segment but keep slashes
  const pathSegments = path.split('/').map(segment => awsUriEncode(segment, true));
  const canonicalUri = path ? '/' + pathSegments.join('/') : '/';
  
  const canonicalQueryString = createCanonicalQueryString(queryParams);
  
  const canonicalHeaders = `host:${endpoint}\nx-amz-content-sha256:${payloadHash}\nx-amz-date:${amzDate}\n`;
  const signedHeaders = "host;x-amz-content-sha256;x-amz-date";
  
  const canonicalRequest = `${method}\n${canonicalUri}\n${canonicalQueryString}\n${canonicalHeaders}\n${signedHeaders}\n${payloadHash}`;
  
  const algorithm = "AWS4-HMAC-SHA256";
  const credentialScope = `${dateStamp}/${region}/${service}/aws4_request`;
  const stringToSign = `${algorithm}\n${amzDate}\n${credentialScope}\n${await sha256(canonicalRequest)}`;
  
  const signingKey = await getSignatureKey(env.WASABI_SECRET_ACCESS_KEY, dateStamp, region, service);
  const signature = await hmacSha256(signingKey, stringToSign);
  
  const authorizationHeader = `${algorithm} Credential=${env.WASABI_ACCESS_KEY_ID}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
  
  // Build actual URL - use same encoding as canonical URI
  const urlParams = new URLSearchParams(queryParams);
  const urlString = `https://${endpoint}${canonicalUri}${urlParams.toString() ? '?' + urlParams.toString() : ''}`;
  
  return {
    url: urlString,
    headers: {
      "Host": endpoint,
      "x-amz-date": amzDate,
      "x-amz-content-sha256": payloadHash,
      "Authorization": authorizationHeader,
    },
  };
}

async function sha256(message) {
  const msgBuffer = new TextEncoder().encode(message);
  const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
}

async function hmacSha256(key, message) {
  const encoder = new TextEncoder();
  const keyData = typeof key === "string" ? encoder.encode(key) : key;
  const cryptoKey = await crypto.subtle.importKey(
    "raw", keyData, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(message));
  const hashArray = Array.from(new Uint8Array(signature));
  return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
}

async function getSignatureKey(key, dateStamp, regionName, serviceName) {
  const encoder = new TextEncoder();
  const kDate = await hmacSha256Raw(encoder.encode("AWS4" + key), dateStamp);
  const kRegion = await hmacSha256Raw(kDate, regionName);
  const kService = await hmacSha256Raw(kRegion, serviceName);
  const kSigning = await hmacSha256Raw(kService, "aws4_request");
  return kSigning;
}

async function hmacSha256Raw(key, message) {
  const encoder = new TextEncoder();
  const keyData = typeof key === "string" ? encoder.encode(key) : key;
  const cryptoKey = await crypto.subtle.importKey(
    "raw", keyData, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(message));
  return new Uint8Array(signature);
}

async function listObjects(env, prefix = "", delimiter = "/") {
  const queryParams = {
    "list-type": "2",
    "delimiter": delimiter,
    "max-keys": "1000",
  };
  
  if (prefix) {
    queryParams.prefix = prefix;
  }
  
  const { url, headers } = await signRequest(env, "GET", "", queryParams);
  
  const response = await fetch(url, { headers });
  
  if (!response.ok) {
    const text = await response.text();
    throw { message: `Failed to list objects: ${text}`, status: response.status };
  }
  
  const xmlText = await response.text();
  return parseListBucketResult(xmlText);
}

function parseListBucketResult(xml) {
  const folders = [];
  const files = [];
  
  const prefixMatches = xml.matchAll(/<CommonPrefixes>.*?<Prefix>(.*?)<\/Prefix>.*?<\/CommonPrefixes>/gs);
  for (const match of prefixMatches) {
    const prefix = match[1];
    const name = prefix.replace(/\/$/, "").split("/").pop();
    folders.push({ name, prefix });
  }
  
  const contentMatches = xml.matchAll(/<Contents>(.*?)<\/Contents>/gs);
  for (const match of contentMatches) {
    const content = match[1];
    const keyMatch = content.match(/<Key>(.*?)<\/Key>/);
    const sizeMatch = content.match(/<Size>(.*?)<\/Size>/);
    const modifiedMatch = content.match(/<LastModified>(.*?)<\/LastModified>/);
    
    if (keyMatch) {
      const key = keyMatch[1];
      if (key.endsWith("/")) continue;
      
      const name = key.split("/").pop();
      const size = sizeMatch ? parseInt(sizeMatch[1]) : 0;
      const lastModified = modifiedMatch ? modifiedMatch[1] : "";
      
      files.push({ name, key, size, lastModified });
    }
  }
  
  return { folders, files };
}

async function handleDownload(env, path) {
  if (!path) {
    throw { message: "No file path provided", status: 400 };
  }
  
  const { url, headers } = await signRequest(env, "GET", path, {});
  
  const response = await fetch(url, { headers });
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error("Download error:", errorText);
    throw { message: `Failed to download file: ${response.status} ${response.statusText}`, status: response.status };
  }
  
  const fileName = path.split("/").pop();
  const fileType = fileName.split(".").pop().toLowerCase();
  const contentType = getContentType(fileType);
  
  return new Response(response.body, {
    headers: {
      "Content-Type": contentType,
      "Content-Disposition": `attachment; filename="${fileName}"`,
      "Cache-Control": "public, max-age=3600",
      "Accept-Ranges": "bytes",
    },
  });
}

async function handleStream(env, path) {
  if (!path) {
    throw { message: "No file path provided", status: 400 };
  }
  
  const { url, headers } = await signRequest(env, "GET", path, {});
  
  const response = await fetch(url, { headers });
  
  if (!response.ok) {
    throw { message: `Failed to stream file: ${response.status}`, status: response.status };
  }
  
  const fileName = path.split("/").pop();
  const fileType = fileName.split(".").pop().toLowerCase();
  
  // For MKV files, serve as video/webm if experimental support is enabled
  // This works for MKV files with VP8/VP9 + Opus/Vorbis codecs
  let contentType = getContentType(fileType);
  if (fileType === "mkv" && CONFIG.experimentalMkvSupport) {
    contentType = "video/webm";
  }
  
  return new Response(response.body, {
    headers: {
      "Content-Type": contentType,
      "Content-Disposition": `inline; filename="${fileName}"`,
      "Cache-Control": "public, max-age=3600",
      "Accept-Ranges": "bytes",
    },
  });
}

async function handlePreview(env, path, request) {
  if (!path) {
    throw { message: "No file path provided", status: 400 };
  }
  
  const fileName = path.split("/").pop();
  const fileType = fileName.split(".").pop().toLowerCase();
  
  // Check if it's a video file
  const videoFormats = ["mp4", "webm", "mkv", "avi", "mov"];
  if (videoFormats.includes(fileType)) {
    const userAgent = request.headers.get("User-Agent") || "";
    return await handleVideoPreview(env, path, fileName, fileType, userAgent);
  }
  
  // Handle other file types (images, PDFs, etc.)
  const { url, headers } = await signRequest(env, "GET", path, {});
  
  const response = await fetch(url, { headers });
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error("Preview error:", errorText);
    throw { message: `Failed to preview file: ${response.status} ${response.statusText}`, status: response.status };
  }
  
  const contentType = getContentType(fileType);
  
  return new Response(response.body, {
    headers: {
      "Content-Type": contentType,
      "Content-Disposition": `inline; filename="${fileName}"`,
      "Cache-Control": "public, max-age=3600",
    },
  });
}

async function handleVideoPreview(env, path, fileName, fileType, userAgent) {
  // Detect browser
  const isFirefox = userAgent.toLowerCase().includes('firefox');
  const isChrome = userAgent.toLowerCase().includes('chrome');
  const isSafari = userAgent.toLowerCase().includes('safari') && !isChrome;
  
  // Create streaming URL
  const streamUrl = `/${path}?stream`;
  
  // Generate video player HTML
  const html = getVideoPlayerPage(streamUrl, fileName, fileType, isFirefox, isChrome, isSafari);
  
  return new Response(html, {
    headers: {
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "public, max-age=300",
    },
  });
}

async function handleBrowse(env, path) {
  const prefix = path ? (path.endsWith("/") ? path : path + "/") : "";
  const { folders, files } = await listObjects(env, prefix);
  
  const html = getBrowsePage(path, folders, files);
  
  return new Response(html, {
    headers: { 
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "public, max-age=300",
    },
  });
}

function getContentType(ext) {
  const types = {
    html: "text/html", htm: "text/html", txt: "text/plain", css: "text/css",
    js: "text/javascript", json: "application/json", xml: "text/xml",
    jpg: "image/jpeg", jpeg: "image/jpeg", png: "image/png", gif: "image/gif",
    svg: "image/svg+xml", ico: "image/x-icon", webp: "image/webp",
    mp4: "video/mp4", webm: "video/webm", mkv: "video/x-matroska",
    avi: "video/x-msvideo", mov: "video/quicktime", mp3: "audio/mpeg",
    wav: "audio/wav", ogg: "audio/ogg", m4a: "audio/mp4", flac: "audio/flac",
    pdf: "application/pdf", doc: "application/msword",
    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    xls: "application/vnd.ms-excel",
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ppt: "application/vnd.ms-powerpoint",
    pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    zip: "application/zip", rar: "application/x-rar-compressed",
    "7z": "application/x-7z-compressed", tar: "application/x-tar", gz: "application/gzip",
  };
  return types[ext] || "application/octet-stream";
}

function formatSize(bytes) {
  if (bytes === 0) return "0 B";
  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

function formatDate(dateString) {
  const date = new Date(dateString);
  return date.toLocaleString();
}

function getFileIcon(name) {
  const ext = name.split(".").pop().toLowerCase();
  const icons = {
    pdf: "üìÑ", doc: "üìù", docx: "üìù", txt: "üìù", xls: "üìä", xlsx: "üìä", csv: "üìä",
    ppt: "üìΩÔ∏è", pptx: "üìΩÔ∏è", jpg: "üñºÔ∏è", jpeg: "üñºÔ∏è", png: "üñºÔ∏è", gif: "üñºÔ∏è",
    svg: "üñºÔ∏è", webp: "üñºÔ∏è", mp4: "üé¨", avi: "üé¨", mkv: "üé¨", mov: "üé¨", webm: "üé¨",
    mp3: "üéµ", wav: "üéµ", ogg: "üéµ", flac: "üéµ", m4a: "üéµ",
    zip: "üì¶", rar: "üì¶", "7z": "üì¶", tar: "üì¶", gz: "üì¶",
    js: "üíª", py: "üíª", java: "üíª", cpp: "üíª", html: "üíª", css: "üíª",
  };
  return icons[ext] || "üìÑ";
}

function getBrowsePage(currentPath, folders, files) {
  const pathParts = currentPath ? currentPath.split("/").filter(p => p) : [];
  const breadcrumbs = pathParts.map((part, index) => {
    const path = "/" + pathParts.slice(0, index + 1).join("/");
    return `<a href="${path}">${part}</a>`;
  }).join(" / ");

  const folderRows = folders.map(folder => `
    <tr class="folder-row">
      <td class="icon">üìÅ</td>
      <td class="name"><a href="/${folder.prefix}">${folder.name}</a></td>
      <td class="size">-</td>
      <td class="modified">-</td>
      <td class="actions"><a href="/${folder.prefix}" class="btn">Open</a></td>
    </tr>
  `).join("");

  const fileRows = files.map(file => `
    <tr class="file-row">
      <td class="icon">${getFileIcon(file.name)}</td>
      <td class="name">${file.name}</td>
      <td class="size">${formatSize(file.size)}</td>
      <td class="modified">${formatDate(file.lastModified)}</td>
      <td class="actions">
        <a href="/${file.key}?download" class="btn btn-download">Download</a>
        ${isPreviewable(file.name) ? `<a href="/${file.key}?preview" class="btn btn-preview">Preview</a>` : ""}
      </td>
    </tr>
  `).join("");

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${CONFIG.siteName}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: ${CONFIG.theme === "dark" ? "#1a1a1a" : "#f5f5f5"};
      color: ${CONFIG.theme === "dark" ? "#e0e0e0" : "#333"};
      padding: 20px; line-height: 1.6;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    header {
      display: flex; align-items: center; margin-bottom: 30px; padding-bottom: 20px;
      border-bottom: 2px solid ${CONFIG.theme === "dark" ? "#333" : "#ddd"};
    }
    .site-icon { font-size: 48px; margin-right: 20px; }
    h1 { font-size: 32px; font-weight: 600; }
    .breadcrumb {
      background: ${CONFIG.theme === "dark" ? "#252525" : "#fff"};
      padding: 15px 20px; border-radius: 8px; margin-bottom: 20px; font-size: 14px;
    }
    .breadcrumb a { color: #0066cc; text-decoration: none; transition: color 0.2s; }
    .breadcrumb a:hover { color: #0052a3; text-decoration: underline; }
    table {
      width: 100%; background: ${CONFIG.theme === "dark" ? "#252525" : "#fff"};
      border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    th {
      background: ${CONFIG.theme === "dark" ? "#1e1e1e" : "#f8f8f8"};
      padding: 15px; text-align: left; font-weight: 600;
      border-bottom: 2px solid ${CONFIG.theme === "dark" ? "#333" : "#e0e0e0"};
    }
    td { padding: 12px 15px; border-bottom: 1px solid ${CONFIG.theme === "dark" ? "#333" : "#f0f0f0"}; }
    tr:last-child td { border-bottom: none; }
    tr:hover { background: ${CONFIG.theme === "dark" ? "#2a2a2a" : "#f9f9f9"}; }
    .icon { width: 40px; text-align: center; font-size: 20px; }
    .name { font-weight: 500; }
    .name a { color: ${CONFIG.theme === "dark" ? "#4d9fff" : "#0066cc"}; text-decoration: none; }
    .name a:hover { text-decoration: underline; }
    .size { width: 100px; }
    .modified { width: 200px; font-size: 13px; color: ${CONFIG.theme === "dark" ? "#888" : "#666"}; }
    .actions { width: 220px; white-space: nowrap; }
    .btn {
      display: inline-block; padding: 6px 12px; margin-right: 5px;
      background: #0066cc; color: white; text-decoration: none;
      border-radius: 4px; font-size: 12px; transition: background 0.2s;
    }
    .btn:hover { background: #0052a3; }
    .btn-preview { background: #28a745; }
    .btn-preview:hover { background: #218838; }
    .empty {
      text-align: center; padding: 60px 20px;
      color: ${CONFIG.theme === "dark" ? "#666" : "#999"};
    }
    footer {
      text-align: center; margin-top: 40px; padding-top: 20px;
      border-top: 1px solid ${CONFIG.theme === "dark" ? "#333" : "#ddd"};
      color: ${CONFIG.theme === "dark" ? "#666" : "#999"}; font-size: 14px;
    }
    @media (max-width: 768px) {
      .modified { display: none; }
      .actions { width: 150px; }
      .btn { padding: 5px 8px; font-size: 11px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="site-icon">${CONFIG.siteIcon}</div>
      <div><h1>${CONFIG.siteName}</h1></div>
    </header>
    <div class="breadcrumb">
      <a href="/">üè† Home</a>
      ${breadcrumbs ? " / " + breadcrumbs : ""}
    </div>
    ${folders.length === 0 && files.length === 0 ? `
      <div class="empty"><h2>üì≠ Empty Folder</h2><p>No files or folders here</p></div>
    ` : `
      <table>
        <thead>
          <tr>
            <th class="icon"></th>
            <th class="name">Name</th>
            <th class="size">Size</th>
            <th class="modified">Modified</th>
            <th class="actions">Actions</th>
          </tr>
        </thead>
        <tbody>${folderRows}${fileRows}</tbody>
      </table>
    `}
    <footer><p>ü™£ Powered by Wasabi S3 Index on Cloudflare Workers</p></footer>
  </div>
</body>
</html>`;
}

function isPreviewable(name) {
  const ext = name.split(".").pop().toLowerCase();
  const previewable = ["jpg", "jpeg", "png", "gif", "svg", "webp", "pdf", "txt", "mp4", "webm", "mkv", "avi", "mov", "mp3", "wav", "ogg"];
  return previewable.includes(ext);
}

function getVideoPlayerPage(streamUrl, fileName, fileType, isFirefox, isChrome, isSafari) {
  const isMkv = fileType === "mkv";
  
  // Browser-specific compatibility info
  let browserInfo = "";
  if (isMkv) {
    if (isFirefox) {
      browserInfo = `
        <div class="info-box firefox">
          <strong>ü¶ä Firefox Detected</strong><br>
          Your browser supports MKV files with VP8, VP9, AV1, and H.264 codecs.
          If playback fails, the file may use unsupported audio codecs (e.g., AC3, DTS).
        </div>
      `;
    } else if (isChrome) {
      browserInfo = `
        <div class="info-box chrome">
          <strong>üåê Chrome Detected</strong><br>
          Chrome can play some MKV files with WebM-compatible codecs (VP8/VP9 + Opus/Vorbis).
          If playback fails, try downloading the file or use Firefox for better MKV support.
        </div>
      `;
    } else if (isSafari) {
      browserInfo = `
        <div class="warning">
          <strong>‚ö†Ô∏è Safari Detected</strong><br>
          Safari has very limited MKV support. We recommend downloading the file
          or using Firefox/Chrome for better compatibility.
        </div>
      `;
    } else {
      browserInfo = `
        <div class="info-box">
          <strong>‚ÑπÔ∏è MKV Playback</strong><br>
          Browser support varies. Firefox 2025+ has the best native MKV support.
          If playback fails, try downloading or using a different browser.
        </div>
      `;
    }
  }

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Player - ${fileName}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      width: 100%;
      max-width: 1200px;
    }
    .header {
      background: #1a1a1a;
      padding: 20px;
      border-radius: 8px 8px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
    }
    .file-info h1 {
      font-size: 20px;
      margin-bottom: 5px;
      word-break: break-word;
    }
    .file-info p {
      color: #999;
      font-size: 14px;
    }
    .actions {
      display: flex;
      gap: 10px;
    }
    .btn {
      padding: 10px 20px;
      background: #0066cc;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-size: 14px;
      transition: background 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: none;
      cursor: pointer;
    }
    .btn:hover { background: #0052a3; }
    .btn-download { background: #28a745; }
    .btn-download:hover { background: #218838; }
    .video-container {
      background: #000;
      border-radius: 0 0 8px 8px;
      overflow: hidden;
      position: relative;
    }
    video {
      width: 100%;
      height: auto;
      max-height: 70vh;
      display: block;
    }
    .warning, .info-box {
      padding: 15px 20px;
      margin-bottom: 20px;
      border-radius: 6px;
      font-size: 14px;
      line-height: 1.6;
    }
    .warning {
      background: #ff9800;
      color: #000;
    }
    .info-box {
      background: #2196F3;
      color: #fff;
    }
    .info-box.firefox {
      background: #FF7139;
    }
    .info-box.chrome {
      background: #4285F4;
    }
    .controls-info {
      background: #1a1a1a;
      padding: 15px 20px;
      margin-top: 20px;
      border-radius: 8px;
      font-size: 13px;
      color: #999;
    }
    .controls-info h3 {
      color: #fff;
      margin-bottom: 10px;
      font-size: 16px;
    }
    .controls-info ul {
      list-style: none;
      padding: 0;
    }
    .controls-info li {
      padding: 5px 0;
    }
    .error-message {
      background: #ff4444;
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      text-align: center;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #999;
    }
    .codec-info {
      background: #252525;
      padding: 15px 20px;
      margin-top: 15px;
      border-radius: 8px;
      font-size: 13px;
      color: #999;
    }
    .codec-info strong {
      color: #fff;
    }
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        align-items: flex-start;
      }
      .file-info h1 { font-size: 16px; }
      .actions { width: 100%; }
      .btn { flex: 1; justify-content: center; }
      video { max-height: 50vh; }
    }
  </style>
</head>
<body>
  <div class="container">
    ${browserInfo}
    
    <div class="header">
      <div class="file-info">
        <h1>üé¨ ${fileName}</h1>
        <p>Format: ${fileType.toUpperCase()} ${isMkv ? '(Matroska Container)' : ''}</p>
      </div>
      <div class="actions">
        <button onclick="history.back()" class="btn">‚Üê Back</button>
        <a href="${streamUrl.replace('?stream', '?download')}" download="${fileName}" class="btn btn-download">‚¨áÔ∏è Download</a>
      </div>
    </div>
    
    <div class="video-container">
      <div class="loading" id="loading">‚è≥ Loading video...</div>
      <video 
        controls 
        preload="metadata"
        playsinline
        controlslist="nodownload"
        oncontextmenu="return true;"
        id="videoPlayer"
        style="display:none;"
      >
        ${isMkv ? `
          <source src="${streamUrl}" type="video/webm; codecs=vp9,opus">
          <source src="${streamUrl}" type="video/webm; codecs=vp8,opus">
          <source src="${streamUrl}" type="video/x-matroska">
        ` : `
          <source src="${streamUrl}" type="${fileType === 'mp4' ? 'video/mp4' : fileType === 'webm' ? 'video/webm' : 'video/quicktime'}">
        `}
        Your browser does not support the video tag or this video format.
      </video>
    </div>
    
    ${isMkv ? `
    <div class="codec-info">
      <strong>üìä MKV Codec Compatibility:</strong><br>
      ‚úÖ Supported: VP8, VP9, AV1, H.264 (video) + Opus, Vorbis (audio)<br>
      ‚ùå Not Supported: H.265/HEVC, AC3, DTS, TrueHD (may require download)<br>
      üí° Tip: Firefox 2025+ has the best native MKV support
    </div>
    ` : ''}
    
    <div class="controls-info">
      <h3>üí° Video Player Controls:</h3>
      <ul>
        <li>‚Ä¢ <strong>Spacebar</strong> - Play/Pause</li>
        <li>‚Ä¢ <strong>‚Üí / ‚Üê</strong> - Skip 5 seconds forward/backward</li>
        <li>‚Ä¢ <strong>‚Üë / ‚Üì</strong> - Volume up/down</li>
        <li>‚Ä¢ <strong>F</strong> - Toggle fullscreen</li>
        <li>‚Ä¢ <strong>M</strong> - Mute/Unmute</li>
        <li>‚Ä¢ ${fileType === "mp4" ? "MP4 is universally supported" : fileType === "mkv" ? "MKV support varies by browser and codec" : "WebM is widely supported"}</li>
      </ul>
    </div>
  </div>
  
  <script>
    const video = document.getElementById('videoPlayer');
    const loading = document.getElementById('loading');
    
    // Show video when it starts loading
    video.addEventListener('loadstart', function() {
      loading.style.display = 'none';
      video.style.display = 'block';
    });
    
    // Error handling with detailed message
    video.addEventListener('error', function(e) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-message';
      
      let errorMsg = 'Unable to play this video in your browser.';
      if (video.error) {
        switch(video.error.code) {
          case 1:
            errorMsg = 'Video loading aborted.';
            break;
          case 2:
            errorMsg = 'Network error while loading video.';
            break;
          case 3:
            errorMsg = 'Video codec not supported by your browser.';
            break;
          case 4:
            errorMsg = 'Video file format not supported.';
            break;
        }
      }
      
      errorDiv.innerHTML = \`
        <h2>‚ö†Ô∏è Playback Error</h2>
        <p>\${errorMsg}</p>
        ${isMkv ? '<p><strong>MKV Troubleshooting:</strong> This file may use codecs not supported by your browser.</p>' : ''}
        <p>Try downloading the file or using a different browser (Firefox recommended for MKV).</p>
        <p style="margin-top: 15px;">
          <a href="${streamUrl.replace('?stream', '?download')}" download="${fileName}" class="btn btn-download" 
             style="display: inline-block; margin-top: 10px;">
            ‚¨áÔ∏è Download Video
          </a>
        </p>
      \`;
      video.parentElement.appendChild(errorDiv);
      video.style.display = 'none';
      loading.style.display = 'none';
    });
    
    // Success feedback
    video.addEventListener('loadedmetadata', function() {
      console.log('‚úÖ Video loaded successfully:', {
        duration: Math.round(video.duration) + 's',
        dimensions: video.videoWidth + 'x' + video.videoHeight,
        hasAudio: video.audioTracks?.length > 0 || video.webkitAudioDecodedByteCount > 0
      });
    });
    
    video.addEventListener('canplay', function() {
      loading.textContent = '‚úÖ Ready to play';
      setTimeout(() => { loading.style.display = 'none'; }, 500);
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      switch(e.key) {
        case ' ':
          e.preventDefault();
          video.paused ? video.play() : video.pause();
          break;
        case 'ArrowRight':
          e.preventDefault();
          video.currentTime = Math.min(video.currentTime + 5, video.duration);
          break;
        case 'ArrowLeft':
          e.preventDefault();
          video.currentTime = Math.max(video.currentTime - 5, 0);
          break;
        case 'ArrowUp':
          e.preventDefault();
          video.volume = Math.min(video.volume + 0.1, 1);
          break;
        case 'ArrowDown':
          e.preventDefault();
          video.volume = Math.max(video.volume - 0.1, 0);
          break;
        case 'f':
        case 'F':
          e.preventDefault();
          if (document.fullscreenElement) {
            document.exitFullscreen();
          } else if (video.requestFullscreen) {
            video.requestFullscreen();
          }
          break;
        case 'm':
        case 'M':
          e.preventDefault();
          video.muted = !video.muted;
          break;
      }
    });
  </script>
</body>
</html>`;
}

function getPasswordPage() {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Protected - ${CONFIG.siteName}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #1a1a1a; color: #e0e0e0; display: flex;
      justify-content: center; align-items: center; height: 100vh; margin: 0;
    }
    .container {
      text-align: center; background: #252525; padding: 40px;
      border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    h1 { margin-bottom: 20px; }
    p { margin-bottom: 30px; color: #999; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîí Protected Area</h1>
    <p>Please enter the password to access this content</p>
  </div>
</body>
</html>`;
}

function getErrorPage(message) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Error - ${CONFIG.siteName}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #1a1a1a; color: #e0e0e0; display: flex;
      justify-content: center; align-items: center; height: 100vh; margin: 0;
    }
    .container {
      text-align: center; background: #252525; padding: 40px;
      border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-width: 500px;
    }
    h1 { color: #ff6b6b; margin-bottom: 20px; }
    p { margin-bottom: 30px; word-break: break-word; }
    a { 
      color: #4d9fff; text-decoration: none; padding: 10px 20px;
      background: #333; border-radius: 6px; display: inline-block;
      transition: background 0.2s;
    }
    a:hover { background: #444; }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚ö†Ô∏è Error</h1>
    <p>${message}</p>
    <a href="/">‚Üê Back to Home</a>
  </div>
</body>
</html>`;
}
